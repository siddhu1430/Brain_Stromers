<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internal Policy Q&A Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-image: linear-gradient(to right, royalblue, maroon); /* Integrated Gradient Background */
            color: #d8b4fe; /* Purple text color */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
            overflow: hidden;
        }
        .container {
            position: relative;
            z-index: 10;
            max-width: 800px;
            width: 100%;
            margin: 20px;
            padding: 24px;
            background-color: rgba(31, 31, 31, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            height: calc(100vh - 40px);
        }
        .header {
            text-align: center;
            margin-bottom: 24px;
            border-bottom: 1px solid #333;
            padding-bottom: 16px;
            position: relative;
            z-index: 20;
        }
        .header h1 {
            font-weight: 600;
            font-size: 2rem;
            color: #fff;
        }
        .chat-container {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding-right: 8px;
            position: relative;
        }
        .chat-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100%;
            height: 100%;
        }
        .chat-message.user, .chat-message.agent {
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 20;
        }
        .chat-message.user {
            align-self: flex-end;
            background-color: rgba(99, 102, 241, 0.9);
            color: #fff;
            border-bottom-right-radius: 2px;
        }
        .chat-message.agent {
            align-self: flex-start;
            background-color: rgba(44, 44, 44, 0.9);
            color: #e0e0e0;
            border-bottom-left-radius: 2px;
        }
        .input-container {
            display: flex;
            margin-top: 24px;
            position: relative;
            z-index: 20;
        }
        .input-container input {
            flex-grow: 1;
            padding: 12px;
            background-color: #2c2c2c;
            border: 1px solid #333;
            border-radius: 12px;
            font-size: 1rem;
            color: #d8b4fe;
            outline: none;
        }
        .input-container input::placeholder {
            color: #888;
        }
        .input-container button {
            background-color: #6366f1;
            color: #fff;
            padding: 12px 20px;
            border-radius: 12px;
            margin-left: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .input-container button:hover {
            background-color: #4f46e5;
        }
        .loading-indicator {
            text-align: center;
            font-style: italic;
            color: #888;
            margin-top: 12px;
            position: relative;
            z-index: 20;
        }
        .source-info {
            font-size: 0.75rem;
            color: #888;
            margin-top: 8px;
            font-style: italic;
        }
        .controls {
            display: flex;
            justify-content: space-around;
            margin-top: 16px;
            padding: 8px 0;
            border-top: 1px solid #333;
            position: relative;
            z-index: 20;
        }
        .controls button {
            background-color: transparent;
            color: #d8b4fe;
            padding: 8px 16px;
            border: 1px solid #444;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s;
        }
        .controls button:hover {
            background-color: #333;
            border-color: #6366f1;
        }
        
        /* Custom scrollbar for WebKit browsers (Chrome, Safari) */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: #2c2c2c;
            border-radius: 10px;
        }
        .chat-container::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 10px;
            border: 2px solid #2c2c2c;
        }
    </style>
</head>
<body class="p-4">
    <div class="container">
        <div class="header">
            <h1>Internal Policy Q&A Agent</h1>
            <p class="text-gray-400">Ask me anything about company policies.</p>
        </div>
        <div id="chat-box" class="chat-container">
            <canvas id="orb-canvas"></canvas>
            </div>
        <div class="input-container">
            <input type="text" id="user-input" placeholder="Send a message...">
            <button id="send-button">Send</button>
        </div>
        <div id="loading-message" class="loading-indicator hidden">
            <p>Thinking...</p>
        </div>
        <div class="controls">
            <button id="download-button">Download Chat</button>
            <button id="clear-button">Clear Chat</button>
        </div>
    </div>

    <script>
        // Data from the provided documents
        const docs = [
            {
                title: "Compliance & IT Usage Guidelines",
                content: `
                    Software Installation: Employees are not allowed to install unauthorized software. All installations must be approved by IT.
                    Data Security: Confidential files must be stored in the secure cloud drive. Sharing via personal email is prohibited.
                    Internet Usage: Office internet should only be used for official purposes. Streaming and downloads are restricted.
                `
            },
            {
                title: "Technical Documentation",
                content: `
                    API Authentication: The API uses OAuth 2.0 for authentication. Obtain an access token via /auth endpoint.
                    User Login: Endpoint: POST /api/v1/login with parameters (username, password). Returns JWT token on success.
                    Password Reset: Users can reset their password by calling POST /api/v1/reset-password with registered email.
                `
            },
            {
                title: "Customer Refund & Return Policy",
                content: `
                    Return Eligibility: Products can be returned within 30 days of delivery if they are unused and in original packaging.
                    Refund Timeline: Refunds will be processed within 7 business days after inspection of the returned product.
                    Escalation: If refunds are delayed beyond 10 days, customers can escalate to support@company.com.
                `
            },
            {
                title: "Company HR Policy",
                content: `
                    Leave Policy: Employees are entitled to 12 casual leaves, 10 sick leaves, and 15 earned leaves annually. Work-from-home requests must be approved by the reporting manager.
                    Reimbursement: Employees can claim travel reimbursements with valid receipts within 30 days of travel. All claims require manager approval.
                    Working Hours: Standard working hours are 9 AM - 6 PM, with flexibility for remote teams.
                `
            },
            {
                title: "Remote_Work",
                content: `
                    Employees working from home must be available on Slack/Teams during office hours. VPN is required for accessing internal systems. All client calls must be attended from a professional environment.
                `
            },
            {
                title: "Onboarding_Guide",
                content: `
                    New employees will receive their laptop, email ID, and access credentials within 2 business days of joining. For ID cards and desk allocation, raise a request via the Facilities Portal.
                `
            },
            {
                title: "Health_and_Safety",
                content: `
                    In case of emergency, dial the office emergency number. Fire exits are marked clearly on each floor. Participate in quarterly fire drills. Maintain an ergonomic workstation to prevent injuries.
                `
            },
            {
                title: "IT_Security",
                content: `
                    All employees must change passwords every 90 days. Multi-factor authentication is mandatory. Company devices must not be used for personal file storage. Report suspicious emails to IT immediately.
                `
            },
            {
                title: "Travel_Policy",
                content: `
                    All travel must be pre-approved. Flight bookings should be economy class unless specified. Hotel stays are capped at $150 per night. Meals during travel are reimbursable up to $40 per day.
                `
            },
            {
                title: "Code_of_Conduct",
                content: `
                    Employees must maintain professionalism, respect colleagues, and follow ethical business practices. Harassment, discrimination, or violation of company values is strictly prohibited.
                `
            }
        ];

        // UI Elements
        const chatBox = document.getElementById('chat-box');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const loadingMessage = document.getElementById('loading-message');
        const downloadButton = document.getElementById('download-button');
        const clearButton = document.getElementById('clear-button');
        let chatHistory = [];

        // Function to add a message to the chat box
        function addMessage(text, sender, source = null) {
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('chat-message', sender);
            
            const messageText = document.createElement('p');
            messageText.textContent = text;
            messageWrapper.appendChild(messageText);

            if (source && sender === 'agent') {
                const sourceInfo = document.createElement('div');
                sourceInfo.classList.add('source-info');
                sourceInfo.innerHTML = `Source: <b>${source}</b>`;
                messageWrapper.appendChild(sourceInfo);
            }

            chatBox.appendChild(messageWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // Function to process the user's question and get a response
        async function getResponse(userQuestion) {
            // Show loading indicator
            loadingMessage.classList.remove('hidden');

            try {
                // Construct a detailed prompt for the LLM
                const prompt = `You are a helpful AI assistant for a company's internal policies. Your task is to answer questions based on the provided documents. You must identify the source document for your answer. If the question cannot be answered by the documents, state that you don't have the information and specify "No Source". The format should be "Answer: [Your response here]. Source: [Source Document Title]".
                
                Documents:
                ${docs.map(doc => `--- ${doc.title} ---\n${doc.content}`).join('\n\n')}

                Question: "${userQuestion}"

                Answer:`;

                // API call to the Gemini 2.5 Flash model for text generation
                let apiChatHistory = [];
                apiChatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: apiChatHistory };
                const apiKey = "AIzaSyAdLzIqbZ--Wf9FMuEivqsTrkSQebgooWA";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                let response;
                let retries = 0;
                const maxRetries = 5;
                let delay = 1000;

                while (retries < maxRetries) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.status === 429) {
                            // Too many requests, retry with exponential backoff
                            retries++;
                            delay *= 2;
                            await new Promise(res => setTimeout(res, delay));
                            continue;
                        }

                        if (!response.ok) {
                            throw new Error(`API response was not ok: ${response.statusText}`);
                        }

                        break; // Success! Exit the loop.
                    } catch (error) {
                        console.error(`Fetch attempt ${retries + 1} failed:`, error);
                        retries++;
                        delay *= 2;
                        await new Promise(res => setTimeout(res, delay));
                    }
                }
                
                if (!response || !response.ok) {
                    throw new Error("Failed to get a successful response from the API after multiple retries.");
                }

                const result = await response.json();
                const rawAgentResponse = result.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I couldn't find an answer to that question in the documents. Source: No Source";
                
                // Parse the response to get the answer and the source
                const answerMatch = rawAgentResponse.match(/Answer: (.*)\. Source: (.*)/);
                let agentResponseText;
                let sourceTitle;

                if (answerMatch && answerMatch.length === 3) {
                    agentResponseText = answerMatch[1].trim();
                    sourceTitle = answerMatch[2].trim();
                } else {
                    agentResponseText = "Sorry, I couldn't find an answer to that question in the documents.";
                    sourceTitle = "No Source";
                }
                
                // Hide loading indicator
                loadingMessage.classList.add('hidden');
                
                addMessage(agentResponseText, 'agent', sourceTitle);

                // Add to chat history for download
                chatHistory.push({ sender: 'user', text: userQuestion });
                chatHistory.push({ sender: 'agent', text: agentResponseText, source: sourceTitle });

            } catch (error) {
                console.error('Error fetching data from API:', error);
                loadingMessage.classList.add('hidden');
                addMessage("I'm sorry, an error occurred while trying to get a response. Please try again.", 'agent', 'Error');
            }
        }

        // Event listener for the Send button
        sendButton.addEventListener('click', () => {
            const userQuestion = userInput.value.trim();
            if (userQuestion) {
                addMessage(userQuestion, 'user');
                getResponse(userQuestion);
                userInput.value = ''; // Clear the input field
            }
        });

        // Event listener for the Enter key in the input field
        userInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                sendButton.click();
            }
        });

        // Event listener for the Download button
        downloadButton.addEventListener('click', () => {
            let fileContent = 'Chat History\n\n';
            chatHistory.forEach(msg => {
                fileContent += `[${msg.sender.toUpperCase()}] ${msg.text}`;
                if (msg.source) {
                    fileContent += ` (Source: ${msg.source})`;
                }
                fileContent += `\n\n`;
            });
            
            const blob = new Blob([fileContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'chat_history.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Event listener for the Clear button
        clearButton.addEventListener('click', () => {
            chatBox.innerHTML = '';
            chatHistory = [];
        });

        // THREE.js Animation
        let scene, camera, renderer, particles;
        let mouseX = 0, mouseY = 0;

        function init() {
            const canvas = document.getElementById('orb-canvas');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);

            // Create particle system
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const particleCount = 2000;
            const size = 50;

            for (let i = 0; i < particleCount; i++) {
                const x = (Math.random() - 0.5) * size;
                const y = (Math.random() - 0.5) * size;
                const z = (Math.random() - 0.5) * size;
                vertices.push(x, y, z);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            const material = new THREE.PointsMaterial({
                color: 0x8A2BE2,
                size: 0.1,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.7
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            camera.position.z = 10;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Simple animation loop
            particles.rotation.x += 0.0005;
            particles.rotation.y += 0.001;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const canvas = document.getElementById('orb-canvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        window.addEventListener('resize', onWindowResize, false);
        window.onload = function() {
            init();
            animate();
        };

    </script>
</body>
</html>